# 指令集

## 说明

在结果位、参数位，使用的标志：
- R 寄存器
- Rn 私有寄存器
- Ran 参数寄存器
- I 标识符（不包含数据标识符）
- Iv 变量标识符
- Idv 动态变量标识符
- Isv 静态变量标识符
- Irv 引用变量标识符
- If 函数标识符
- D 数据（包含数据标识符）
- Ds 短数据
- Dl 长数据
- Di 数据标识符
- \- 无

指令模式：
- \<S\> 静态模式：只有在静态模式下有效。
- \<D\> 动态模式：只有在动态模式下有效。

无标记表示所有模式均有效。

## 寄存器指令

指令|模式|结果位|第一参数|说明
---|-|------|-------|-----
mov||R|R|将某一寄存器的数据传送给另一寄存器
mvds||R|Ds|将短数据传送给寄存器
mvdl||R|Dl|将长数据的索引传送给寄存器
mvdv||R|Idv|将动态变量的数据传送给寄存器
mvsv||R|Isv|将静态变量的数据传送给寄存器
mvrv||R|Irv|将引用变量的数据传送给寄存器

## 函数调用指令

指令|模式|结果位|第一参数|其他参数|多参？|说明
---|-|------|-------|--------|-----|-----
farg||-|D/I/R||√|将参数打包
fcal||R|R/If|||调用函数，使用打包的参数
ffce||-|R|||检查是否为函数
face||-|R/If|||检查对于已打包的参数，函数调用是否合法
ret||-||||从当前函数中返回
call||R|R/If|D/I/R|√|伪指令，在汇编期间转化为farg与fcal

当变量存储了函数时，需要经过如下操作：

```
; (let f +)
let  f, +  ; 将 + 通过 let 操作赋给 变量 f

; (f 5 6)
mvdv %1, f  ; 将动态变量 f 存储的函数对象移至寄存器%1中。
ffce %1     ; 检查 %1 寄存器是否为函数对象。若不是则抛出异常。
farg 5 6    ; 将 5 和 6 作为参数打包。
face %1     ; 检查参数对 %1 的调用是否合法。若不是则抛出异常。
fcal %2, %1 ; 调用函数 %1，即 f，也即 + ；并将结果传给 %2 寄存器。
```

当然，通过一定的预先检验（通常为在编译期的静态检查），可以省略部分运行时检查代码。优化后的代码如下：

```
; (f 5 6)
mvdv %1, f
farg 5 6
fcal %2, %1
```

## 变量操作指令

指令|模式 |结果位|第一参数|说明
---|-----|------|-------|-----
let|\<D\>| Iv |D/I/R| 使用let操作
set|\<D\>| Iv |D/I/R| 使用set操作
cpy|\<D\>| Iv/R |D/I/R| 使用cpy操作
ref|\<D\>| Iv/R |D/I/R| 使用ref操作
