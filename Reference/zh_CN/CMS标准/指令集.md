# 指令集

## 说明

在结果位、参数位，使用的标志：
- R 寄存器
- Rn 私有寄存器
- Ran 参数寄存器
- I 标识符（不包含数据标识符）
- Iv 变量标识符
- Idv 动态变量标识符
- Isv 静态变量标识符
- Irv 引用变量标识符
- If 函数标识符
- It 类型标识符
- D 数据（包含数据标识符）
- Ds 短数据
- Dl 长数据
- Di 数据标识符
- T 类型（包含类型标识符）
- \- 无

指令模式：
- \<S\> 静态模式：只有在静态模式下有效。
- \<D\> 动态模式：只有在动态模式下有效。

无标记表示所有模式均有效。

## 寄存器指令

运行模式不同，会导致数据寄存器（包括私有寄存器、通用寄存器、全局寄存器等）的结构发生变化。凡涉及数据寄存器的，必然要区分运行模式。

指令|模式|结果位|第一参数|辅助参数|说明
---|----|------|-------|-------|-----
mov|\<S\>\<D\>|R|R||将某一寄存器保存的数据传送给另一寄存器
mvd|\<S\>|R|Ds||将数据传送给寄存器*
mvd|\<D\>|R|Ds|T|将数据与类型打包生成的对象传送给寄存器
mvdv|\<S\>|R|Idv||将动态变量的数据传送给寄存器
mvdv|\<D\>|R|Idv||将动态变量的索引传送给寄存器
mvsv|\<S\>|R|Isv||将静态变量的数据传送给寄存器
mvsv|\<D\>|R|Isv||将静态变量的索引传送给寄存器
mvrv|\<S\>|R|Irv||将引用变量所引用的变量的数据传送给寄存器
mvrv|\<D\>|R|Irv||将引用变量所引用的变量的索引传送给寄存器

\* 静态模式下数据赋入方式：短数据直接覆写，长数据覆写索引。

## 函数调用指令

函数调用指令与被调用函数的运行模式息息相关，也与当前函数的运行模式有关。

指令|模式|结果位|第一参数|其他参数|多参？|说明
---|-|------|-------|--------|-----|-----
farg||-|D/I/R||√|将参数打包
fcal||R|R/If|||调用函数，使用打包的参数
ffce||-|R|||检查是否为函数
face||-|R/If|||检查对于已打包的参数，函数调用是否合法
ret||-||||从当前函数中返回
call||R|R/If|D/I/R|√|伪指令，在汇编期间转化为farg与fcal

当变量存储了函数时，需要经过如下操作：

```
; (let f +)
let  f, +  ; 将 + 通过 let 操作赋给 变量 f

; (f 5 6)
mvdv %1, f  ; 将动态变量 f 存储的函数对象移至寄存器%1中。
ffce %1     ; 检查 %1 寄存器是否为函数对象。若不是则抛出异常。
farg 5 6    ; 将 5 和 6 作为参数打包。
face %1     ; 检查参数对 %1 的调用是否合法。若不是则抛出异常。
fcal %2, %1 ; 调用函数 %1，即 f，也即 + ；并将结果传给 %2 寄存器。
```

当然，通过一定的预先检验（通常为在编译期的静态检查），可以省略部分运行时检查代码。优化后的代码如下：

```
; (f 5 6)
mvdv %1, f
farg 5 6
fcal %2, %1
```

## 变量操作指令

指令|模式 |结果位|第一参数|说明
---|-----|------|-------|-----
let|\<D\>| Iv |D/I/R| 使用let操作
set|\<D\>| Iv |D/I/R| 使用set操作
cpy|\<D\>| Iv/R |D/I/R| 使用cpy操作
ref|\<D\>| Iv/R |D/I/R| 使用ref操作
