# CMS 标准

CMS (CM Assembler) 是 ICM 编译源代码生成的中间表示。可以直接运行在 CVM 虚拟机上，也可以通过 CCM (Compiler for CM) 编译为相应平台的机器指令或虚拟码。

CMS 是一种高度抽象的中间表示。

## 概述

CMS 主要由四个段组成：

- .datas 段 ： 存放各种数据
- .idents 段 ： 对于各种标识符进行声明。
- .imports 段 ： 对于库的导入。
- .code 段 ： 主要的运行代码。

给定一个 Chill 语言的源程序：

```
(let a "Hello ")
(let b "World ")
(println (+ a b))

(dim c Int)
(set c 0x100)
(println c)

(define d (+ 5 7))
(println d)

(defunc f [str]
  (return str))
(println (f "call f."))

(module Math
  (define pi 3.14)
)
(println Math.pi)
```

经过 ICM 会生成如下 CMS 代码：

```
;; Main.cms

.datas:
        .string #1   "Hello "
        .string #2   "World!"
        .string #3   "call f."

.idents:
        .module Math
        .data   Math#pi   3.14
        .entry  main

.imports:
        .import %Core
        .using  Core
        .using  println Core#Console#println
        
.codes:

f:
        .mode static
        mov  %res, %1
        ret

main:
        .mode dynamic
        .dyvarb a    %1
        .dyvarb b    %2
        .stvarb c    %3, Int
        .data   d    12
        let  a, #1, String
        let  b, #2, String
        call %4, Core#String#+, a b
        call %0, println, %1
        set  c, 0x100
        call %0, println, c
        call %0, println, d
        call %4, f, #3
        call %0, println, %4
        call %0, println, Math#pi
        ret
```

## 数据

CMS 的数据分为可存放于指令中的短数据 与 只能存放于数据段的长数据。

短数据 是 不大于 32位 的数据。包括但不限于：
- Boolean 类型数据。
- Int8, Int16, Int32, UInt8, UInt16, UInt32 等机器无关的不超过32位的定长数据。

长数据 是 长度超过 32位，或者不定长的数据。包括但不限于：
- String 字符串数据。
- Int64, UInt64 等机器无关的超过32位定长数据。

机器相关的数据具有未知的长度，根据具体的编译时信息来确定。包括但不限于：

- Int, UInt, Float, Double 等不定长数据。
- CPointer C 指针数据。

## 符号表

符号的区分是 Chill 语言一个重要的功能。
Chill 语言共有以下几种符号：

- data     : 数据
- dyvarb   : 动态变量
- stvarb   : 静态变量
- func     : 函数
- module   : 模块
- struct   : 结构

每个文件，只要使用了符号，都要引用符号表。
不同文件可以共用一个符号表，也可以在每个文件内单独维护一个符号表。

## 符号的使用

CMS 的符号设计，尽量保证大多数语言能够无障碍地将标识符直接书写于 CMS 中。

在 Chill 语言、 常见的 Lisp 方言 (如Scheme, Common Lisp) 中，标识符允许数字、字母以及：
```
 ! $ % & * + - . / : < = > ? @ ^ _ ~
 ```
 等作为标识符的命名，其中数字不能开头。(Chill 不允许```.```符号)

在 C语言 以及其他参照 C语言命名法的语言（如 C++，Java 等） 中，标识符的允许仅为 数字、字母以及下划线。

考虑以上，选用 ```#``` 符号作为特殊符号。

当存在使用了 ```%``` 符号命名的标识符时， 使用 ```%%``` 代替 ```%```。

如：

```
(defunc % [x y] (return (Core.Calc.% x y)))
```

通常编译为：

```
%%:
        call %res, Core#Calc#%%, %1, %2
        ret
```


## 寄存器

### 种类

CMS 是基于寄存器的，且寄存器数目在理论上是无限多的。

CMS 寄存器有如下几种：

- 通用寄存器： %t + 数字，数字为 从 1 开始的整数。每个线程间是相互独立的。
- 全局寄存器： %g + 数字，数字为 从 1 开始的整数。跨线程的共有寄存器。
- 私有寄存器： % + 数字，数字为 从 1 开始的整数。函数等进程私有的寄存器。
- 结果寄存器： %res ， 存储函数调用的结果的寄存器，实际上是调用函数指令中所指明的目标寄存器。
- 参数寄存器： %a + 数字，数字为 从 1 开始的整数。 参数寄存器在指令fcal中使用，实际上是将被调用函数的私有寄存器。

示例：

```
mov %1, %2
```

就是将 2 号 寄存器里的数据送入 1 号 寄存器中。

有时，不希望储存结果时，通过使用 %0 来表示舍弃运算的结果。

出于多线程的考虑，每个线程下都有名称相同的通用寄存器组，在不同线程下，调用不同的通用寄存器组。因此不会由通用寄存器冲突引发线程问题。

### 数据

寄存器通常存储函数调用的结果，或者代码中硬性赋入的初值。

一个动态变量在存储数据时，包含类型信息和数据的地址。

如
```
(let a 5i32)

; a 的结构表示（理论意义，不同实现有所不同）：
{
  type : Int32,
  data : int32_t* -> 5
}
```

而静态变量的存储则为：

```
data : 5
; or
data : int32_t* -> 5
```

因涉及到实现的便利性问题，通常将寄存器开辟为动态变量所需空间的大小，作为静态变量使用时，直接从最初的位置开始的整个空间作为存储数据的空间。

因此，为避免出现寄存器引用的混乱，编译器应该具有 **自动区分引用了动态变量数据的寄存器和引用（或存储）了静态变量数据的寄存器** 的能力。

## 函数调用过程

函数调用前，先将需传入参数打包。打包的参数作为函数内的%n寄存器使用。

%res寄存器是存储输出参数的寄存器。通常将%res设置为调用时设置的结果寄存器。

fcal 传入的函数是一个整型的索引，函数的索引是平铺的。

每个文件都使用一个函数表。
函数表可以是共用的，也可以在每个文件内使用独立函数表。

CMS 在调用函数时，并不要求运行 CMS 代码的虚拟机（如CVM）或者进一步编译的程序能够自动检查函数调用的正确性。 CMS 提供了专门负责检查正确性的指令，编译器在产生 CMS 代码时，应该具有 **能够在编译期识别错误或者将在合适位置正确生成检查代码** 的能力。

## 运行模式

在函数定义段的开头，会有如下标记：
.mode XXX
表示函数的运行模式。

不同模式下，寄存器的存储、指令的行为是不同的。

- static 静态模式。这种模式下，寄存器存储的是数据或指向数据的指针，不带有类型信息。
- dynamic 动态模式。这种模式下，寄存器存储的是指向对象的指针，类型动态存储。
- multiply 混合模式。这种模式的运行状态为调用者所期待的运行状态。

### 判断依据

- 含有动态元（动态变量）的函数，一定以动态模式运行。
- 不在运行时处理类型信息的函数，默认以静态模式运行。

### 调用方式

父\子 | static | dynamic | multiply
--|--|--|--
static|直接调用|调用时加上类型信息，返回时去除类型信息|static模式运行
dynamic|调用时去除类型信息，返回时加上类型信息|直接调用|dynamic模式运行

## 指令集

### 说明

在结果位、参数位，使用的标志：
- R 寄存器
- Rn 私有寄存器
- Ran 参数寄存器
- I 标识符（不包含数据标识符）
- Iv 变量标识符
- Idv 动态变量标识符
- Isv 静态变量标识符
- Irv 引用变量标识符
- If 函数标识符
- D 数据（包含数据标识符）
- Ds 短数据
- Dl 长数据
- Di 数据标识符
- \- 无

### 寄存器指令

指令|结果位|第一参数|说明
---|------|-------|-----
mov|R|R|将某一寄存器的数据传送给另一寄存器
mvds|R|Ds|将短数据传送给寄存器
mvdl|R|Dl|将长数据的索引传送给寄存器
mvdv|R|Idv|将动态变量的数据传送给寄存器
mvsv|R|Isv|将静态变量的数据传送给寄存器
mvrv|R|Irv|将引用变量的数据传送给寄存器

### 函数调用指令

指令|结果位|第一参数|其他参数|多参？|说明
---|------|-------|--------|-----|-----
farg|-|D/I/R||√|将参数打包
fcal|R|R/If|||调用函数，使用打包的参数
ffce|-|R|||检查是否为函数
face|-|R/If|||检查对于已打包的参数，函数调用是否合法
ret|-||||从当前函数中返回
call|R|R/If|D/I/R|√|伪指令，在汇编期间转化为farg与fcal

当变量存储了函数时，需要经过如下操作：

```
; (let f +)
let  f, +  ; 将 + 通过 let 操作赋给 变量 f

; (f 5 6)
mvdv %1, f  ; 将动态变量 f 存储的函数对象移至寄存器%1中。
ffce %1     ; 检查 %1 寄存器是否为函数对象。若不是则抛出异常。
farg 5 6    ; 将 5 和 6 作为参数打包。
face %1     ; 检查参数对 %1 的调用是否合法。若不是则抛出异常。
fcal %2, %1 ; 调用函数 %1，即 f，也即 + ；并将结果传给 %2 寄存器。
```

当然，通过一定的预先检验（通常为在编译期的静态检查），可以省略部分运行时检查代码。优化后的代码如下：

```
; (f 5 6)
mvdv %1, f
farg 5 6
fcal %2, %1
```

### 变量操作指令

指令|结果位|第一参数|说明
---|------|-------|-----
let| Iv |D/I/R| 使用let操作
set| Iv |D/I/R| 使用set操作
cpy| Iv/R |D/I/R| 使用cpy操作
ref| Iv/R |D/I/R| 使用ref操作
