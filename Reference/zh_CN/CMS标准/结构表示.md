# CMS 结构表示

这里的表示为当前 CVM 实现的表示。

## 对象 (Object)

目前的 CVM 实现中， 对象 由两个部分组成：

```
struct Object
{
    TypeUnit type;     // 类型标识符
    DataPointer data;  // 数据指针
};
```

其中，TypeUnit = size_t，是一个 机器相关 的无符号整型，DataPointer = void* 也是一个长度 与 机器相关 的指针类型。

## 寄存器 (Register)

寄存器用于保存临时的数据，如函数调用的结果。

函数调用的结果可能是纯数据，也可能是带有类型信息的对象。

因此，一个寄存器必须至少能够保存一个Object。

目前的 CVM 实现中， 寄存器 直接使用 Object 表示：

```
using Register = Object;
```

当已确定在某个函数内所有寄存器均只保存数据时，寄存器将使用单独的数据来表示。

```
using Register = DataPointer;
```

【注】为方便起见，通常直接使用 Object 来表示寄存器。

## 变量 (Variable)

变量有三种，分别是 动态变量 (Dynamic Variable) ， 静态变量 (Static Variable) 和 引用变量 (Reference Variable) 。

### 动态变量 (Dynamic Variable)

动态变量需要一个指针来指向对象，即一个Object指针。
同时，有的动态变量会存在一种类型约束，因此也需要记录类型信息，即 TypeUnit 数据。

因此，直接地，将 动态变量 表示为一个 Object 对象。

```
using DyVarb = Object;
```

### 静态变量 (Static Variable)

静态变量 是只包含数据的变量。
在只处理静态变量的程序中，类型信息在编译期被完全地处理，此时 静态变量 的类型信息是不必要的。

```
using StVarb = DataPointer;
```

而有的时候，需要进行动态的类型检查，或者需要将动态变量 打包为静态变量。为了方便起见，在静态变量里附加自带的类型信息。在程序运行过程中不会更改。

此时直接使用 Object 来表示静态变量。

```
using StVarb = Object;
```

【注】为方便起见，通常直接使用 Object 来表示静态变量。

### 引用变量 (Reference Variable)

引用变量 可表示为指向变量的指针。

```
using RfVarb = Object*;
```

## 函数 (Function)

函数是编译期确定的 可调用二进制地址 或 可执行代码段 和附加的 符号表组成的结构。

CVM 自带了一些函数，这些函数已经编译为二进制代码。调用这些函数时，直接使用提供的地址即可。

表示这种函数时，直接使用指向这个地址的指针即可。

同时，用户可能自定义了一些函数。

表示这种函数时，至少拥有 可执行的代码段。

自定义函数中可能拥有符号表，但这在运行过程中不是必须的，因此可以省略。

```
f:
    .stvarb a Int32
    .stvarb b Int32
    set  a, 5, Int32
    set  b, 6, Int32
    call %1, Core$Int32$+, a b
    call %0, println, %1
    ret
```

这段代码中，函数 f 被表示为 包含了 a 和 b 两个符号的符号表，以及所需要运行的代码段。

函数在保存时，仅仅保存符号与代码段；在调用的时候，会根据保存的符号来分配对应的空间。

单独的函数标识符被表示为一个 对函数的索引 (FunctionIndex)。

```
using IdentFunc = FunctionIndex;
```

函数可被变量保存。

将存储有函数的变量视为函数来调用的时候，变量本身不能直接作为函数。

同时，因为寄存器的字节大小往往大于函数标识符的字节大小，因此不能提供一个通用的、用于寄存器与函数标识符的指令。

是以，在 CVM 的内部，从 函数标识符 调用和从 寄存器 中调用函数的指令的实现是不同的。

```
call %0, f

mvf  %1, f
call %0, %1
```
